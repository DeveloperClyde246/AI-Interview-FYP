make it so the link pass relevant value to streamlit then streamlit get from database the response details and show output

//--------this is RecruiterCandidateDetails.jsx
import React, { useEffect, useState } from "react";
import axios from "axios";
import { useParams, Link } from "react-router-dom";
import RecruiterNavbar from "../components/RecruiterNavbar";
import "../styles/recruiter/RecruiterCandidateDetails.css";
import { useNavigate } from "react-router-dom";

const RecruiterCandidateDetails = () => {
  const { interviewId, candidateId } = useParams();
  const [data, setData] = useState(null);
  const [error, setError] = useState("");
  const navigate = useNavigate();

  // Fetch candidate details when component mounts or params change
  useEffect(() => {
    const fetchDetails = async () => {
      try {
        const res = await axios.get(
          `http://localhost:5000/recruiter/candidate-details/${interviewId}/${candidateId}`,
          { withCredentials: true }
        );
        setData(res.data);
      } catch (err) {
        console.error("Error loading candidate details:", err);
        setError("Failed to load candidate details.");
      }
    };
    fetchDetails();
  }, [interviewId, candidateId]);

  if (error) return <p className="error">{error}</p>;
  if (!data) return <p className="loading">Loading...</p>;

  const { candidate, response } = data;

  return (
    <div className="candidate-details-container">
      <RecruiterNavbar />
      <div className="candidate-details-card">
        <h2>Candidate Profile</h2>
        <div className="candidate-info">
          <p>
            <strong>Name:</strong> {candidate?.name}
          </p>
          <p>
            <strong>Email:</strong> {candidate?.email}
          </p>
          <p>
            <strong>Contact Number:</strong>{" "}
            {candidate?.contactNumber || "Not provided"}
          </p>
          <p>
            <strong>Role Applied:</strong>{" "}
            {candidate?.roleApplied || "Not specified"}
          </p>
          <p>
            <strong>Introduction:</strong>{" "}
            {candidate?.introduction || "No introduction provided."}
          </p>
        </div>

        <div className="section">
          <h3>Skills</h3>
          {candidate?.skills && candidate.skills.length > 0 ? (
            <ul className="list">
              {candidate.skills.map((skill, idx) => (
                <li key={idx}>{skill}</li>
              ))}
            </ul>
          ) : (
            <p>No skills listed.</p>
          )}
        </div>

        <div className="section">
          <h3>Education</h3>
          {candidate?.education && candidate.education.length > 0 ? (
            <ul className="list">
              {candidate.education.map((edu, idx) => (
                <li key={idx}>
                  {edu.degree} from {edu.institution} ({edu.yearOfCompletion})
                </li>
              ))}
            </ul>
          ) : (
            <p>No education details provided.</p>
          )}
        </div>

        {response ? (
          <>
            <div className="section">
              <h3>Submitted Answers</h3>
              <ol className="answers-list">
                {response.answers.map((ans, i) => (
                  <li key={i}>
                    {ans.startsWith("http") ? (
                      <>
                        <a href={ans} target="_blank" rel="noreferrer">
                          View File
                        </a>{" "}
                        |{" "}
                        <a
                          href={`http://localhost:8501/upload_file?video_url=${encodeURIComponent(
                            ans
                          )}`}
                          target="_blank"
                          rel="noreferrer"
                        >
                          Analysis Details
                        </a>
                      </>
                    ) : (
                      ans
                    )}
                  </li>
                ))}
              </ol>
            </div>

            {response.videoMarks?.length > 0 && (
              <div className="section">
                <h3>Video Marks</h3>
                <ul className="list">
                  {response.videoMarks.map((mark, i) => (
                    <li key={i}>Video {i + 1}: {mark} marks</li>
                  ))}
                </ul>
                <p className="average-mark">
                  <strong>Average Mark:</strong> {response.marks}
                </p>
              </div>
            )}
          </>
        ) : (
          <p className="no-response"><i>This candidate has not submitted answers yet.</i></p>
        )}

        <div className="back-btn-container">
        <button onClick={() => navigate("/recruiter/interview-results")} className="back-btn">
  ← Back to Results
</button>
        </div>
      </div>
    </div>
  );
};

export default RecruiterCandidateDetails;



//-----------this is streamlit result_page.py
import streamlit as st
import tempfile
import requests
import numpy as np
import pandas as pd
import joblib
import langcodes
import plotly.express as px
import plotly.graph_objects as go
import matplotlib.pyplot as plt
import librosa

st.set_page_config(layout="wide")
st.title("AI Interview Evaluation Dashboard (from JSON)")

# 1️⃣ Let the user enter your API URL and upload a file
api_url = st.text_input("Analysis API endpoint", "http://localhost:5001/analyze")
uploaded_file = st.file_uploader("Upload your video/audio file", type=["mp4","avi","mov","mkv","mp3","wav"])

if api_url and uploaded_file:
    # POST to your Flask API
    with st.spinner("Sending to analysis API…"):
        files = {"file": (uploaded_file.name, uploaded_file.getvalue())}
        resp = requests.post(api_url, files=files)
    if not resp.ok:
        st.error(f"API error: {resp.status_code} {resp.text}")
        st.stop()

    data = resp.json()

    # load the same label‑encoder so we know the emotion names
    le = joblib.load("tone_analysis_dashboard/emotion_model/emotion_label_encoder.joblib")
    emotion_classes = list(le.classes_)

    # set up the five tabs
    tab1, tab2, tab3, tab4, tab5 = st.tabs([
        "Emotion + Fluency",
        "Personality Analysis",
        "Text Emotion & Stress",
        "Facial Expression + Eye Gaze",
        "Final Score"
    ])

    # ─── TAB 1: Emotion + Fluency ──────────────────────────────────────────────
    with tab1:
        st.header("🎭 Emotion Analysis + Fluency Level")

        # Pie chart of the ensemble probabilities
        for model_name, scores in data["emotion_results"].items():
            fig = px.pie(
                values=scores,
                names=emotion_classes,
                title=f"{model_name} Distribution",
                color=emotion_classes,
                color_discrete_sequence=px.colors.qualitative.Pastel
            )
            st.plotly_chart(fig)

        # show each %  
        st.write("**Probabilities:**")
        for emo, p in zip(emotion_classes, data["emotion_results"][model_name]):
            st.write(f"- {emo}: {p*100:.2f}%")

        # Most likely
        st.write(f"**Most Likely Emotion:** {data['most_likely_emotion'].capitalize()}")
        # Compute confidence & consistency client‑side:
        probs = np.array(data["emotion_results"][model_name])
        st.write(f"**Confidence:** {probs.max()*100:.2f}%")
        st.write(f"**Consistency:** {probs.std()*100:.2f}%")

        # fluency
        st.write(f"**Fluency Level:** {data['fluent_level']}")

        # final interview score (tab1)
        st.success(f"🎯 Emotion Interview Score: {data['interview_score_tab1']:.2f} / 10")

    # ─── TAB 2: Personality ────────────────────────────────────────────────────
    with tab2:
        st.header("🧠 Personality Trait Analysis")

        scores = data["personality_scores"]
        traits = ["Neuroticism","Extraversion","Agreeableness","Conscientiousness","Openness"]

        # radar
        fig = px.line_polar(r=scores, theta=traits, line_close=True, 
                            title="Personality Radar")
        st.plotly_chart(fig)

        # bar % overlay
        fig2 = go.Figure()
        fig2.add_trace(go.Bar(y=traits, x=[1]*5, orientation="h",
                              marker=dict(color="lightgray"), showlegend=False))
        fig2.add_trace(go.Bar(y=traits, x=scores, orientation="h",
                              marker=dict(color="orange"),
                              text=[f"{v*100:.1f}%" for v in scores],
                              textposition="inside", showlegend=False))
        fig2.update_layout(barmode="overlay", xaxis_range=[0,1],
                           title="Traits %")
        st.plotly_chart(fig2)

        st.success(f"🎯 Personality Interview Score: {data['interview_score_tab2']:.2f} / 10")

    # ─── TAB 3: Text‑Based Emotion & Stress ───────────────────────────────────
    with tab3:
        st.header("🗣️ Text-Based Emotion & Stress Analysis")
        st.write(f"**Detected Language:** {langcodes.get(data['detected_language']).display_name()}")
        st.write(f"**Transcript:** {data['transcript']}")

        st.write(f"**Stress Detected:** {'Yes' if data['stress_detected'] else 'No'}")
        st.write(f"**Text Emotion:** {data['text_emotion'].capitalize()}")

        st.success(f"🎯 Combined Text Score: {data['interview_score_tab3']:.2f} / 10")

    # ─── TAB 4: Facial Expression + Eye Gaze ─────────────────────────────────
    with tab4:
        st.header("😶 Facial Expression & Eye Gaze Analysis")

        # Emotion distribution table & chart
        df_em = pd.DataFrame(data["emotion_distribution"])
        st.subheader("🎭 Facial Emotion Distribution")
        fig3, ax3 = plt.subplots()
        ax3.bar(df_em["Emotions"], df_em["Frames"],
                color=["#FF9999","#66B2FF","#99FF99","#FFCC99","#FFD700","#87CEFA","#90EE90"])
        ax3.set_ylabel("Frames"); ax3.set_xlabel("Emotions")
        ax3.set_title("Emotion Distribution")
        plt.xticks(rotation=45)
        st.pyplot(fig3)

        st.write("### Distribution Table")
        st.table(df_em)

        st.write(f"**Predominant Emotion:** {data['max_emotion']}")
        st.write(f"**Facial Emotion Score:** {data['average_emotion_score']:.2f} / 10")

        # Eye gaze
        df_gz = pd.DataFrame(data["eye_gaze_distribution"])
        st.subheader("👀 Eye Gaze Distribution")
        fig4, ax4 = plt.subplots()
        ax4.bar(df_gz["Eye Gaze"], df_gz["Frames"],
                color=["#FF9999","#66B2FF","#99FF99"])
        ax4.set_ylabel("Frames"); ax4.set_xlabel("Eye Gaze")
        ax4.set_title("Eye Gaze Distribution")
        plt.xticks(rotation=45)
        st.pyplot(fig4)

        st.write("### Distribution Table")
        st.table(df_gz)

        st.write(f"**Predominant Eye Gaze:** {data['max_eye_gaze']}")
        st.write(f"**Eye Gaze Score:** {data['final_eye_gaze_score']:.2f} / 10")

        # combined tab4 score
        st.success(f"🎯 Facial+Gaze Score: {data['interview_score_tab4']:.2f} / 10")

    # ─── TAB 5: Final Score ───────────────────────────────────────────────────
    with tab5:
        st.header("🏆 Overall Interview Final Score")
        st.markdown(f"""
        <div style='
            background-color: #e6f2ff;
            padding: 18px;
            border-radius: 10px;
            text-align: center;
            font-size: 30px;
            color: #1a1a1a;
            font-weight: bold;
            border: 3px solid #009688;
        '>
            🌟 Final AI Interview Score: <span style='color:#007ACC'>{data['final_average_score']:.2f} / 10</span>
        </div>
        """, unsafe_allow_html=True)
